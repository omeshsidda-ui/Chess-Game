<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Chess vs AI — Fair Play Practice</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css" crossorigin="anonymous" referrerpolicy="no-referrer"/>
  <style>
    :root { --bg:#0f172a; --card:#111827; --text:#e5e7eb; --muted:#9ca3af; --accent:#22c55e; --warn:#f59e0b; }
    *{ box-sizing:border-box; }
    body{ margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; background:linear-gradient(180deg,#0b1020,#0f172a); color:var(--text);} 
    .wrap{ max-width:1100px; margin:24px auto; padding:0 16px; }
    .grid{ display:grid; grid-template-columns: 1fr 360px; gap:20px; }
    .card{ background:var(--card); border:1px solid #1f2937; border-radius:16px; padding:16px; box-shadow:0 10px 25px rgba(0,0,0,.25);} 
    h1{ font-size: clamp(20px, 2.6vw, 28px); margin:0 0 6px 0; }
    .sub{ color:var(--muted); font-size:14px; margin-bottom:14px; }
    #board{ width:100%; max-width: 640px; margin:auto; border-radius:12px; overflow:hidden; box-shadow:0 12px 30px rgba(0,0,0,.35);} 
    .controls label{ display:block; font-size:13px; color:var(--muted); margin-bottom:6px; }
    .controls input[type="range"], .controls input[type="number"]{ width:100%; }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    button{ cursor:pointer; border:1px solid #1f2937; background:#0b1222; color:var(--text); padding:10px 12px; border-radius:12px; font-weight:600; transition: transform .02s ease-in-out, opacity .2s; }
    button:hover{ opacity:.9; }
    button:active{ transform: scale(.98); }
    .primary{ background: linear-gradient(135deg, #16a34a, #22c55e); border:none; color:#04130a; }
    .status{ font-variant-numeric: tabular-nums; font-size:14px; color:var(--muted); }
    .tag{ display:inline-block; background:#0b1222; border:1px solid #1f2937; color:var(--muted); padding:4px 8px; border-radius:999px; font-size:12px; margin-right:6px; }
    .select{ width:100%; padding:10px; border-radius:12px; border:1px solid #1f2937; background:#0b1222; color:var(--text); }
    .footer{ text-align:center; color:#6b7280; font-size:12px; margin-top:18px; }
    .banner{ display:flex; gap:10px; align-items:flex-start; background:rgba(245,158,11,.12); border:1px solid rgba(245,158,11,.35); color:#f8d48a; padding:10px 12px; border-radius:12px; margin-bottom:12px; font-size:13px; }
    .switch{ display:inline-flex; align-items:center; gap:8px; cursor:pointer; user-select:none; }
    .switch input{ appearance:none; width:40px; height:22px; background:#1f2937; border:1px solid #374151; border-radius:999px; position:relative; outline:none; transition:.2s; }
    .switch input:checked{ background:#16a34a; }
    .switch input::after{ content:""; width:18px; height:18px; background:#fff; border-radius:50%; position:absolute; top:1px; left:1px; transition:.2s; }
    .switch input:checked::after{ left:21px; }
    .watermark{ position:absolute; top:10px; right:10px; font-weight:700; font-size:11px; color:#94a3b8; letter-spacing:.12em; padding:4px 8px; border-radius:999px; border:1px dashed #334155; background:rgba(30,41,59,.6); }
    .boardwrap{ position:relative; }
    @media (max-width: 960px){ .grid{ grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Chess vs AI — Practice Board</h1>
    <div class="sub">Play against a chess engine with optional <strong>human‑style practice</strong> quirks. <em>Fair play:</em> don’t use this to cheat or to evade detection on any platform.</div><div class="grid">
  <div class="card">
    <div class="banner">⚠️ <div><strong>Fair‑Play Reminder:</strong> This bot is for learning and offline fun. It is <u>not</u> designed to help you hide engine use. Many sites prohibit assistance during games—respect their rules.</div></div>
    <div class="boardwrap">
      <div id="board"></div>
      <div class="watermark" id="wm">AI PRACTICE BOT</div>
    </div>
    <div class="row" style="margin-top:14px; justify-content:space-between;">
      <div class="status" id="status">Your move.</div>
      <div>
        <span class="tag" id="turnTag">White to move</span>
        <span class="tag" id="evalTag">Eval: —</span>
        <span class="tag" id="depthTag">Depth: —</span>
      </div>
    </div>
  </div>

  <div class="card">
    <div class="controls">
      <label>Play as</label>
      <select id="side" class="select">
        <option value="white">White</option>
        <option value="black">Black</option>
      </select>
    </div>
    <div class="controls" style="margin-top:12px;">
      <label>Engine Elo Cap</label>
      <input id="elo" type="range" min="1200" max="2800" step="50" value="1800" />
      <div class="status">Elo: <span id="eloVal">1800</span></div>
    </div>
    <div class="controls" style="margin-top:12px;">
      <label>Base Engine Move Time (ms)</label>
      <input id="movetime" type="range" min="100" max="3000" step="100" value="900" />
      <div class="status">ms: <span id="movetimeVal">900</span></div>
    </div>

    <hr style="border-color:#1f2937; margin:14px 0;"/>
    <div class="row" style="justify-content:space-between;">
      <label class="switch"><input id="humanStyle" type="checkbox"/> <span>Human‑Style Practice</span></label>
      <span class="tag">clearly labeled • ethical use only</span>
    </div>
    <div id="humanPanel" style="opacity:.5; pointer-events:none;">
      <div class="controls" style="margin-top:12px;">
        <label>Thinking Time Jitter (± ms)</label>
        <input id="jitter" type="range" min="0" max="2500" step="50" value="600" />
        <div class="status">± <span id="jitterVal">600</span> ms (varies each move)</div>
      </div>
      <div class="controls" style="margin-top:12px;">
        <label>Mistake Rate (inaccuracies) %</label>
        <input id="mistake" type="range" min="0" max="40" step="1" value="12" />
        <div class="status"><span id="mistakeVal">12</span>%</div>
      </div>
      <div class="controls" style="margin-top:12px;">
        <label>Blunder Rate %</label>
        <input id="blunder" type="range" min="0" max="20" step="1" value="4" />
        <div class="status"><span id="blunderVal">4</span>%</div>
      </div>
    </div>

    <div class="row" style="margin-top:14px;">
      <button class="primary" id="newBtn">New Game</button>
      <button id="undoBtn">Undo</button>
      <button id="flipBtn">Flip Board</button>
    </div>
    <div class="footer">Promotions auto‑queen. This tool is for practice; do not use it during rated online games.</div>
  </div>
</div>

  </div>  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.13.4/chess.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>  <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>  <script>
    // --- Stockfish Engine (Web Worker) ---
    const ENGINE_URL = 'https://cdn.jsdelivr.net/npm/stockfish@16.1.0/src/stockfish.wasm.js';
    let engine = null;
    let engineReady = false;

    function initEngine() {
      if (engine) { engine.terminate(); engine = null; }
      engineReady = false;
      engine = new Worker(ENGINE_URL);

      engine.onmessage = (e) => {
        const line = typeof e.data === 'string' ? e.data : e.data?.data;
        if (!line) return;
        if (line === 'uciok') {
          engineReady = true;
          setEngineStrength();
          maybeAIMove();
        }
        if (line.startsWith('info ')) {
          const depthMatch = line.match(/\bdepth (\d+)\b/);
          if (depthMatch) depthTag.textContent = 'Depth: ' + depthMatch[1];
          const scoreMatch = line.match(/score (cp|mate) (-?\d+)/);
          if (scoreMatch) {
            let evalStr = '—';
            if (scoreMatch[1] === 'cp') {
              const pawns = (parseInt(scoreMatch[2],10) / 100).toFixed(2);
              evalStr = (game.turn() === 'w' ? pawns : (-pawns)).toString();
            } else {
              evalStr = 'Mate ' + scoreMatch[2];
            }
            evalTag.textContent = 'Eval: ' + evalStr;
          }
        }
        if (line.startsWith('bestmove')) {
          const parts = line.split(' ');
          const moveUci = parts[1];
          if (pendingHumanModeChoice) {
            // If human‑style decided to override, ignore engine move
            return;
          }
          if (moveUci && moveUci !== '(none)') {
            const move = { from: moveUci.slice(0,2), to: moveUci.slice(2,4), promotion: 'q' };
            game.move(move);
            board.position(game.fen());
            updateStatus();
          }
        }
      };

      engine.postMessage('uci');
    }

    function setEngineStrength(){
      const elo = parseInt(eloInput.value,10);
      engine.postMessage('setoption name UCI_AnalyseMode value false');
      engine.postMessage('setoption name UCI_LimitStrength value true');
      engine.postMessage('setoption name UCI_Elo value ' + elo);
    }

    // --- Human‑Style practice knobs ---
    function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
    function coin(p){ return Math.random() < p; }

    function chooseHumanStyleMove(){
      // Very simple "humanization": occasionally make imperfect choices.
      // This is for OFFLINE PRACTICE ONLY — not to evade detection.
      const legals = game.moves({ verbose:true });
      if (legals.length === 0) return null;

      const blunderP = parseInt(blunderInput.value,10) / 100;   // random move
      const mistakeP = parseInt(mistakeInput.value,10) / 100;   // random from subset

      // Try a mild heuristic subset (checks, captures, or developing minor piece)
      const subset = legals.filter(m => (
        m.flags.includes('c') || // capture
        m.san.includes('+') ||   // check
        ['n','b'].includes(m.piece) // minor piece move
      ));

      if (coin(blunderP)) {
        return legals[randInt(0, legals.length-1)];
      }
      if (coin(mistakeP) && subset.length) {
        return subset[randInt(0, subset.length-1)];
      }
      // Default: let engine pick bestmove; we'll return null and allow engine to move
      return null;
    }

    let pendingHumanModeChoice = false;

    function goEngine(){
      if (!engineReady) return;
      engine.postMessage('stop');
      engine.postMessage('ucinewgame');
      engine.postMessage('position fen ' + game.fen());
      const base = parseInt(movetimeInput.value,10);
      const jitter = humanStyle.checked ? parseInt(jitterInput.value,10) : 0;
      const delay = base + (jitter ? randInt(-jitter, jitter) : 0);

      if (humanStyle.checked){
        // Try making a human‑style move first
        const choice = chooseHumanStyleMove();
        if (choice){
          pendingHumanModeChoice = true;
          setTimeout(() => {
            game.move({ from: choice.from, to: choice.to, promotion:'q' });
            board.position(game.fen());
            updateStatus();
            pendingHumanModeChoice = false;
          }, Math.max(50, delay));
          return; // skip engine this turn
        }
      }

      // Otherwise ask engine
      setTimeout(() => {
        engine.postMessage('go movetime ' + Math.max(50, delay));
      }, 10);
    }

    // --- Chessboard / Game Logic ---
    const statusEl = document.getElementById('status');
    const turnTag = document.getElementById('turnTag');
    const evalTag = document.getElementById('evalTag');
    const depthTag = document.getElementById('depthTag');
    const sideSelect = document.getElementById('side');
    const eloInput = document.getElementById('elo');
    const movetimeInput = document.getElementById('movetime');
    const humanStyle = document.getElementById('humanStyle');
    const jitterInput = document.getElementById('jitter');
    const mistakeInput = document.getElementById('mistake');
    const blunderInput = document.getElementById('blunder');

    const eloVal = document.getElementById('eloVal');
    const movetimeVal = document.getElementById('movetimeVal');
    const jitterVal = document.getElementById('jitterVal');
    const mistakeVal = document.getElementById('mistakeVal');
    const blunderVal = document.getElementById('blunderVal');

    let game = new Chess();
    let board = null;

    function onDragStart (source, piece) {
      if (game.game_over()) return false;
      const playingWhite = sideSelect.value === 'white';
      if (playingWhite && piece.search(/^b/) !== -1) return false;
      if (!playingWhite && piece.search(/^w/) !== -1) return false;
      if ((playingWhite && game.turn() !== 'w') || (!playingWhite && game.turn() !== 'b')) return false;
    }

    function onDrop (source, target) {
      const move = game.move({ from: source, to: target, promotion: 'q' });
      if (move === null) return 'snapback';
      updateStatus();
      window.setTimeout(maybeAIMove, 100);
    }

    function onSnapEnd () { board.position(game.fen()); }

    function updateStatus(){
      let status = '';
      let moveColor = game.turn() === 'w' ? 'White' : 'Black';
      if (game.in_checkmate()) {
        status = 'Game over, ' + moveColor + ' is checkmated.';
      } else if (game.in_draw()) {
        status = 'Game over, drawn position.';
      } else {
        status = moveColor + ' to move.';
        if (game.in_check()) status += ' ' + moveColor + ' is in check.';
      }
      statusEl.textContent = status;
      turnTag.textContent = (game.turn() === 'w' ? 'White' : 'Black') + ' to move';
    }

    function maybeAIMove(){
      const playingWhite = sideSelect.value === 'white';
      const aiTurn = (game.turn() === 'b' && playingWhite) || (game.turn() === 'w' && !playingWhite);
      if (!aiTurn || game.game_over()) return;
      goEngine();
    }

    function newGame(){
      game.reset();
      board.orientation(sideSelect.value);
      board.position('start');
      updateStatus();
      setEngineStrength();
      if (sideSelect.value === 'black') {
        setTimeout(maybeAIMove, 150);
      }
    }

    function undo(){
      if (game.history().length === 0) return;
      game.undo();
      if (game.history().length) game.undo();
      board.position(game.fen());
      updateStatus();
    }

    function initBoard(){
      board = Chessboard('board', {
        draggable: true,
        position: 'start',
        onDragStart: onDragStart,
        onDrop: onDrop,
        onSnapEnd: onSnapEnd,
        pieceTheme: 'https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/img/chesspieces/wikipedia/{piece}.png'
      });
      updateStatus();
    }

    // UI wiring
    document.getElementById('newBtn').addEventListener('click', newGame);
    document.getElementById('undoBtn').addEventListener('click', undo);
    document.getElementById('flipBtn').addEventListener('click', () => board.flip());
    sideSelect.addEventListener('change', newGame);
    eloInput.addEventListener('input', () => { eloVal.textContent = eloInput.value; setEngineStrength(); });
    movetimeInput.addEventListener('input', () => { movetimeVal.textContent = movetimeInput.value; });
    humanStyle.addEventListener('change', () => {
      const panel = document.getElementById('humanPanel');
      if (humanStyle.checked){ panel.style.opacity = 1; panel.style.pointerEvents = 'auto'; }
      else { panel.style.opacity = .5; panel.style.pointerEvents = 'none'; }
    });
    jitterInput.addEventListener('input', () => { jitterVal.textContent = jitterInput.value; });
    mistakeInput.addEventListener('input', () => { mistakeVal.textContent = mistakeInput.value; });
    blunderInput.addEventListener('input', () => { blunderVal.textContent = blunderInput.value; });

    // Startup
    initBoard();
    initEngine();
  </script></body>
</html>
